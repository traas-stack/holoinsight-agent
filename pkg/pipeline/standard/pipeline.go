/*
 * Copyright 2022 Holoinsight Project Authors. Licensed under Apache-2.0.
 */

package standard

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/influxdata/telegraf"
	"github.com/spf13/cast"
	containerhelpermodel "github.com/traas-stack/holoinsight-agent/cmd/containerhelper/model"
	"github.com/traas-stack/holoinsight-agent/pkg/accumulator"
	"github.com/traas-stack/holoinsight-agent/pkg/appconfig"
	"github.com/traas-stack/holoinsight-agent/pkg/collecttask"
	"github.com/traas-stack/holoinsight-agent/pkg/collecttask/collecttaskcri"
	"github.com/traas-stack/holoinsight-agent/pkg/core"
	"github.com/traas-stack/holoinsight-agent/pkg/cri"
	"github.com/traas-stack/holoinsight-agent/pkg/ioc"
	"github.com/traas-stack/holoinsight-agent/pkg/logger"
	"github.com/traas-stack/holoinsight-agent/pkg/meta"
	"github.com/traas-stack/holoinsight-agent/pkg/model"
	"github.com/traas-stack/holoinsight-agent/pkg/pipeline/integration/base"
	api2 "github.com/traas-stack/holoinsight-agent/pkg/plugin/api"
	telegraf2 "github.com/traas-stack/holoinsight-agent/pkg/telegraf"
	"github.com/traas-stack/holoinsight-agent/pkg/transfer"
	"github.com/traas-stack/holoinsight-agent/pkg/util"
	"github.com/traas-stack/holoinsight-agent/pkg/util/recoverutils"
	"go.uber.org/zap"
	"sync"
	"time"
)

type (
	Pipeline struct {
		interval time.Duration
		task     *collecttask.CollectTask
		input    interface{}
		output   *Output

		// commonTags will be attached to metrics generated by this pipeline
		commonTags       map[string]string
		cachedAttachTags map[string]string
		metricWhitelist  map[string]struct{}
		metricBlacklist  map[string]struct{}

		stopCh    chan struct{}
		stoppedCh chan struct{}

		transform base.Transform

		state *internalState
		mutex sync.RWMutex

		lastMetricValueCache map[string]float64
		scriptManager        *scriptManager
	}
	internalState struct {
		timer *util.AlignedTimer
	}
)

const (
	defaultExecTimeout = 5 * time.Second
)

func (p *Pipeline) Key() string {
	return p.task.Key
}

func (p *Pipeline) SetupConsumer(st *api2.SubTask) error {
	return nil
}

func (p *Pipeline) Update(f func(api2.Pipeline)) {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	f(p)
}

func (p *Pipeline) View(f func(api2.Pipeline)) {
	p.mutex.RLock()
	defer p.mutex.RUnlock()

	f(p)
}

func NewPipeline(task *collecttask.CollectTask, baseConf *base.Conf, input interface{}, output *Output) (*Pipeline, error) {
	tags := make(map[string]string, len(baseConf.RefMetas))
	for key, item := range baseConf.RefMetas {
		value := task.Target.Meta[item.Name]
		if value == "" && task.Target.Type == collecttask.TargetLocalhost {
			switch item.Name {
			case "app":
				value = appconfig.StdAgentConfig.App
			case "ip":
				value = util.GetLocalIp()
			case "host":
				fallthrough
			case "hostname":
				value = util.GetHostname()
			}
		}
		if value != "" {
			tags[key] = value
		}
	}
	meta.SuppressCommonTags(tags)

	intervalMills := 0
	offsetMills := 0
	// 现在只支持这个
	executeRule := baseConf.ExecuteRule
	switch executeRule.Type {
	case "fixedRate":
		intervalMills = cast.ToInt(executeRule.FixedRate)
		offsetMills = executeRule.Offset
	}
	if intervalMills <= 0 {
		intervalMills = 60_000
	}
	interval := time.Duration(intervalMills) * time.Millisecond
	offset := time.Duration(offsetMills) * time.Millisecond

	timer, _ := util.NewAlignedTimer(interval, offset, false, false)

	if baseConf.Transform.MetricPrefix == "" {
		if ip, ok := input.(api2.Input); ok {
			baseConf.Transform.MetricPrefix = ip.GetDefaultPrefix()
		}
	}

	metricWhitelist := util.ConvertStringSliceToHashSet(baseConf.Transform.MetricWhitelist)
	metricBlacklist := util.ConvertStringSliceToHashSet(baseConf.Transform.MetricBlacklist)

	return &Pipeline{
		interval:        interval,
		task:            task,
		input:           input,
		output:          output,
		commonTags:      tags,
		metricWhitelist: metricWhitelist,
		metricBlacklist: metricBlacklist,
		stopCh:          make(chan struct{}),
		stoppedCh:       make(chan struct{}),
		state: &internalState{
			timer: timer,
		},
		transform:     baseConf.Transform,
		scriptManager: newScriptManager(task.Key, baseConf.Transform.Scripts, task.Target.Meta),
	}, nil
}
func (p *Pipeline) Start() error {
	go p.taskLoop()
	return nil
}

func (p *Pipeline) Stop() {
	p.mutex.Lock()
	defer p.mutex.Unlock()
	p.stop0()
}

func (p *Pipeline) stop0() {
	if p.isStopped() {
		return
	}
	close(p.stopCh)
	logger.Infoz("[pipeline] stop", zap.String("key", p.task.Key))
}

func (p *Pipeline) isStopped() bool {
	select {
	case <-p.stopCh:
		return true
	default:
		return false
	}
}

func (p *Pipeline) taskLoop() {
	// No need to defer stop timer

	timer := p.state.timer

	for {
		select {
		case <-p.stopCh:
			return
		case <-timer.C:
			func() {
				p.mutex.Lock()
				defer p.mutex.Unlock()
				if p.isStopped() {
					return
				}

				// TODO need an option to determine which metric time to use
				metricTime := timer.NextEmitTime().Truncate(p.interval).Add(-p.interval)

				recoverutils.WithRecover(func() { p.collectOnce(metricTime) })
				timer.Next()
			}()
		}
	}
}

func (p *Pipeline) collectOnce(metricTime time.Time) {
	m := &accumulator.Memory{}
	begin := time.Now()
	err := p.collectOnce0(m)

	var sendCost time.Duration
	if len(m.Metrics) > 0 {
		p.transformMetrics(metricTime, m)
		sendBegin := time.Now()
		p.output.Write(m.Metrics)
		sendCost = time.Now().Sub(sendBegin)
	}
	cost := time.Now().Sub(begin)

	if logger.IsDebugEnabled() {
		for _, m := range m.Metrics {
			logger.Debugz("[pipeline] collect once debug", //
				zap.String("key", p.task.Key),               //
				zap.String("metric", m.Name),                //
				zap.Time("ts", time.UnixMilli(m.Timestamp)), //
				zap.Any("tags", m.Tags),                     //
				zap.Float64("value", m.Value),               //
			)
		}
	}

	logger.Infoz("[pipeline] collect once done", //
		zap.Time("ts", metricTime),             //
		zap.String("key", p.task.Key),          //
		zap.String("type", p.task.Config.Type), //
		zap.Int("metrics", len(m.Metrics)),     //
		zap.Duration("sendCost", sendCost),     //
		zap.Duration("cost", cost),             //
		zap.Error(err))
}

func (p *Pipeline) UpdateFrom(old api2.Pipeline) {
	old2, ok := old.(*Pipeline)
	if !ok {
		return
	}
	if p.interval == old2.interval {
		p.state = old2.state
		p.lastMetricValueCache = old2.lastMetricValueCache
		if ext, ok := p.input.(api2.InputExt); ok {
			ext.UpdateFrom(old2.input)
		}
	}
}

// collectOnceWithExec collects datum by executing commands inside target container.
func (p *Pipeline) collectOnceWithExec(ine api2.InputExtNsEnter, m *accumulator.Memory) error {

	biz, err := collecttaskcri.GetTargetContainerE(ioc.Crii, p.task.Target)
	if err != nil {
		return err
	}

	state, actionType, reqBytes, timeout, err := ine.SerializeRequest()
	if err != nil {
		return err
	}

	if timeout <= 0 {
		timeout = defaultExecTimeout
	}

	// Add extra timeout
	ctx, cancel := context.WithTimeout(context.Background(), timeout+3*time.Second)
	defer cancel()

	execResult, err := ioc.Crii.Exec(ctx, biz, cri.ExecRequest{
		Cmd:   []string{core.HelperToolPath, "inputProxy", actionType},
		Input: bytes.NewBuffer(reqBytes),
	})

	if err != nil {
		stdout, stderr := execResult.SampleOutput()
		logger.Errorz("[pipeline] collect once by exec error", //
			zap.String("key", p.task.Key),            //
			zap.String("cmd", execResult.Cmd),        //
			zap.Int("exitcode", execResult.ExitCode), //
			zap.String("stdout", stdout),             //
			zap.String("stderr", stderr),             //
			zap.Error(err))                           //
	} else {
		bytesResp := containerhelpermodel.RespDataBytes{}
		err = json.Unmarshal(execResult.Stdout.Bytes(), &bytesResp)
		err = ine.ProcessResponse(state, bytesResp.Data, err, m)
	}

	return err
}

func (p *Pipeline) collectOnce0(m *accumulator.Memory) error {
	switch i := p.input.(type) {
	case telegraf.Input:
		return i.Gather(telegraf2.Adapt(m, "_"))
	case api2.Input:
		// In some envs, there is network isolation between holoinsight-agent pod and target pod.
		// In this case, plugins such as network detection can only be executed by entering the container through docker exec.
		// The first version of this code was written for runc, and we used the nsenter tool for this purpose.
		// But then we encountered rund, and nsenter's solution didn't work for it. At this point we can only use the standard docker.
		// Currently, some methods are still named with the 'nsenter' keyword, which will remove these couplings in the future.
		if ine, ok := p.input.(api2.InputExtNsEnter); ok && ine.NetworkMode() == api2.NetworkModePod {
			if err := p.collectOnceWithExec(ine, m); err != nil {
				ine.GenerateErrorMetrics(m)
				return err
			}
			return nil
		} else {
			return i.Collect(m)
		}
	default:
		return fmt.Errorf("unsupported input %v", p.input)
	}
}

// getTargetAttachTags returns tags associated with collect target
func (p *Pipeline) getTargetAttachTags() map[string]string {
	// This value is never changed when it is generated
	if len(p.cachedAttachTags) > 0 {
		return p.cachedAttachTags
	}

	var attachTags map[string]string

	switch p.task.Target.Type {
	case collecttask.TargetPod:
		namespace := p.task.Target.GetNamespace()
		podName := p.task.Target.GetPodName()
		if pod, err := ioc.Crii.GetPod(namespace, podName); err == nil {
			attachTags = meta.ExtractPodCommonTags(pod.Pod)
		}
	case collecttask.TargetLocalhost:
		attachTags = meta.ExtractSidecarTags()
	}
	p.cachedAttachTags = attachTags
	return attachTags
}

func (p *Pipeline) transformMetrics(metricTime time.Time, m *accumulator.Memory) {
	if p.lastMetricValueCache == nil {
		p.lastMetricValueCache = make(map[string]float64)
	}
	attachTags := p.getTargetAttachTags()

	ts := metricTime.UnixMilli()

	keep := make([]*model.Metric, 0, len(m.Metrics))
	lastMetricValueCache := p.lastMetricValueCache
	metricValueCache := make(map[string]float64)
	p.lastMetricValueCache = metricValueCache

	for i := range m.Metrics {
		metric := m.Metrics[i]
		if len(p.metricWhitelist) > 0 {
			if _, ok := p.metricWhitelist[metric.Name]; !ok {
				continue
			}
		}
		if len(p.metricBlacklist) > 0 {
			if _, ok := p.metricBlacklist[metric.Name]; ok {
				continue
			}
		}

		metric.Timestamp = ts

		if mc, ok := p.transform.MetricConfigs[metric.Name]; ok {
			metricKey := model.BuildMetricKey(metric)
			metricValueCache[metricKey] = metric.Value

			if mc.ValueManipulation == base.ValueManipulationDelta || mc.ValueManipulation == base.ValueManipulationRate {
				lastPeriodMetric, ok := lastMetricValueCache[metricKey]
				// no last period metric
				if !ok {
					continue
				}

				delta := metric.Value - lastPeriodMetric
				if delta < 0 && !mc.KeepNegative {
					delta = 0
				}

				if mc.ValueManipulation == base.ValueManipulationDelta {
					metric.Value = delta
				} else {
					seconds := p.interval.Seconds()
					if seconds == 0 {
						continue
					}
					metric.Value = delta / seconds
				}
			}
		}

		if metric.Tags == nil {
			metric.Tags = make(map[string]string)
		}
		util.MergeStringMapTo(p.commonTags, metric.Tags, false)
		util.MergeStringMapTo(attachTags, metric.Tags, false)
		keep = append(keep, metric)
	}
	m.Metrics = keep

	m.Metrics = p.scriptManager.run(m.Metrics)

	if x := p.transform.MetricPrefix; x != "" {
		for _, metric := range m.Metrics {
			metric.Name = x + metric.Name
		}
	} else if x := p.transform.MetricFormat; x != "" {
		for _, metric := range m.Metrics {
			metric.Name = fmt.Sprintf(x, metric.Name)
		}
	}
}

func (p *Pipeline) StopAndSaveState(store transfer.StateStore) error {
	p.mutex.Lock()
	defer p.mutex.Unlock()

	if p.isStopped() {
		return errors.New("pipeline is stopped")
	}

	p.stop0()

	prefix := "pipeline@" + p.task.Key

	if si, ok := p.input.(transfer.StatefulInput); ok {
		if b, err := si.SaveState(); err != nil {
			return err
		} else {
			store.Put(prefix+"@input", b)
		}
	}

	if timerState, err := p.state.timer.SaveState(); err != nil {
		return err
	} else {
		store.Put(prefix+"@timer", timerState)
	}

	return nil
}

func (p *Pipeline) LoadState(store transfer.StateStore) error {
	prefix := "pipeline@" + p.task.Key
	if si, ok := p.input.(transfer.StatefulInput); ok {
		if inputState, err := store.Get(prefix + "@input"); err != nil {
			return err
		} else if err := si.LoadState(inputState); err != nil {
			return err
		}
	}

	if timerState, err := store.Get(prefix + "@timer"); err != nil {
		return err
	} else if err := p.state.timer.LoadState(timerState.([]byte)); err != nil {
		return err
	}

	return nil
}
